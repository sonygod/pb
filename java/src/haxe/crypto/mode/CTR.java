// Generated by Haxe 4.0.0-rc.5+b1fb4afca
package haxe.crypto.mode;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class CTR extends haxe.lang.HxObject
{
	public CTR(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public CTR()
	{
		//line 5 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
		haxe.crypto.mode.CTR.__hx_ctor_haxe_crypto_mode_CTR(this);
	}
	
	
	protected static void __hx_ctor_haxe_crypto_mode_CTR(haxe.crypto.mode.CTR __hx_this)
	{
	}
	
	
	public static void encrypt(haxe.io.Bytes src, haxe.io.Bytes iv, int blockSize, haxe.lang.Function encryptBlock)
	{
		//line 9 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
		haxe.io.Bytes vector = null;
		//line 10 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
		haxe.io.Bytes vkey = iv.sub(0, iv.length);
		//line 11 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
		int i = 0;
		//line 12 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
		int len = src.length;
		//line 13 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
		while (( i < len ))
		{
			//line 15 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
			vector = vkey.sub(0, vkey.length);
			//line 16 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
			encryptBlock.__hx_invoke4_o(0.0, vector, ((double) (0) ), haxe.lang.Runtime.undefined, 0.0, vector, ((double) (0) ), haxe.lang.Runtime.undefined);
			//line 18 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
			int block = ( (( ( i + blockSize ) > len )) ? (( len - i )) : (blockSize) );
			//line 19 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
			{
				//line 19 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
				int _g = 0;
				//line 19 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
				int _g1 = block;
				//line 19 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
				while (( _g < _g1 ))
				{
					//line 19 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
					int j = _g++;
					//line 21 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
					src.b[( i + j )] = ((byte) (( ( src.b[( i + j )] & 255 ) ^ ( vector.b[j] & 255 ) )) );
				}
				
			}
			
			//line 24 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
			int j1 = blockSize;
			//line 25 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
			while (( j1-- >= 0 ))
			{
				//line 26 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
				vkey.b[j1] = ((byte) (( (( vkey.b[j1] & 255 )) + 1 )) );
				//line 27 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
				if (( (( vkey.b[j1] & 255 )) != 0 )) 
				{
					//line 27 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
					break;
				}
				
			}
			
			//line 30 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
			i += blockSize;
		}
		
	}
	
	
	public static void decrypt(haxe.io.Bytes src, haxe.io.Bytes iv, int blockSize, haxe.lang.Function decryptBlock)
	{
		//line 36 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\CTR.hx"
		haxe.crypto.mode.CTR.encrypt(src, iv, blockSize, decryptBlock);
	}
	
	
}


