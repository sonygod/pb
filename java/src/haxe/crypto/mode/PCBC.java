// Generated by Haxe 4.0.0-rc.5+b1fb4afca
package haxe.crypto.mode;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class PCBC extends haxe.lang.HxObject
{
	public PCBC(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public PCBC()
	{
		//line 5 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		haxe.crypto.mode.PCBC.__hx_ctor_haxe_crypto_mode_PCBC(this);
	}
	
	
	protected static void __hx_ctor_haxe_crypto_mode_PCBC(haxe.crypto.mode.PCBC __hx_this)
	{
	}
	
	
	public static void encrypt(haxe.io.Bytes src, haxe.io.Bytes iv, int blockSize, haxe.lang.Function encryptBlock)
	{
		//line 9 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		haxe.io.Bytes vector = iv.sub(0, iv.length);
		//line 10 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		int i = 0;
		//line 11 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		int len = src.length;
		//line 12 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		while (( i < len ))
		{
			//line 14 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			haxe.io.Bytes plainText = src.sub(i, blockSize);
			//line 15 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			{
				//line 15 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				int _g = 0;
				//line 15 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				int _g1 = blockSize;
				//line 15 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				while (( _g < _g1 ))
				{
					//line 15 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
					int j = _g++;
					//line 17 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
					src.b[( i + j )] = ((byte) (( ( src.b[( i + j )] & 255 ) ^ ( vector.b[j] & 255 ) )) );
				}
				
			}
			
			//line 20 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			encryptBlock.__hx_invoke4_o(0.0, src, ((double) (i) ), haxe.lang.Runtime.undefined, 0.0, src, ((double) (i) ), haxe.lang.Runtime.undefined);
			//line 21 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			vector = src.sub(i, blockSize);
			//line 22 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			{
				//line 22 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				int _g2 = 0;
				//line 22 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				int _g3 = blockSize;
				//line 22 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				while (( _g2 < _g3 ))
				{
					//line 22 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
					int j1 = _g2++;
					//line 24 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
					vector.b[j1] = ((byte) (( ( vector.b[j1] & 255 ) ^ ( plainText.b[j1] & 255 ) )) );
				}
				
			}
			
			//line 26 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			i += blockSize;
		}
		
	}
	
	
	public static void decrypt(haxe.io.Bytes src, haxe.io.Bytes iv, int blockSize, haxe.lang.Function decryptBlock)
	{
		//line 32 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		haxe.io.Bytes vector = iv.sub(0, iv.length);
		//line 33 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		int i = 0;
		//line 34 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		int len = src.length;
		//line 35 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
		while (( i < len ))
		{
			//line 37 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			haxe.io.Bytes cipherText = src.sub(i, blockSize);
			//line 38 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			decryptBlock.__hx_invoke4_o(0.0, src, ((double) (i) ), haxe.lang.Runtime.undefined, 0.0, src, ((double) (i) ), haxe.lang.Runtime.undefined);
			//line 39 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			{
				//line 39 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				int _g = 0;
				//line 39 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				int _g1 = blockSize;
				//line 39 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				while (( _g < _g1 ))
				{
					//line 39 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
					int j = _g++;
					//line 40 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
					src.b[( i + j )] = ((byte) (( ( src.b[( i + j )] & 255 ) ^ ( vector.b[j] & 255 ) )) );
				}
				
			}
			
			//line 41 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			vector = src.sub(i, blockSize);
			//line 42 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			{
				//line 42 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				int _g2 = 0;
				//line 42 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				int _g3 = blockSize;
				//line 42 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
				while (( _g2 < _g3 ))
				{
					//line 42 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
					int j1 = _g2++;
					//line 44 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
					vector.b[j1] = ((byte) (( ( vector.b[j1] & 255 ) ^ ( cipherText.b[j1] & 255 ) )) );
				}
				
			}
			
			//line 46 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\PCBC.hx"
			i += blockSize;
		}
		
	}
	
	
}


