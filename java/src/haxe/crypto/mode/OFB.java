// Generated by Haxe 4.0.0-rc.5+b1fb4afca
package haxe.crypto.mode;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class OFB extends haxe.lang.HxObject
{
	public OFB(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public OFB()
	{
		//line 5 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
		haxe.crypto.mode.OFB.__hx_ctor_haxe_crypto_mode_OFB(this);
	}
	
	
	protected static void __hx_ctor_haxe_crypto_mode_OFB(haxe.crypto.mode.OFB __hx_this)
	{
	}
	
	
	public static void encrypt(haxe.io.Bytes src, haxe.io.Bytes iv, int blockSize, haxe.lang.Function encryptBlock)
	{
		//line 9 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
		haxe.io.Bytes vector = iv.sub(0, iv.length);
		//line 10 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
		int i = 0;
		//line 11 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
		int len = src.length;
		//line 12 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
		haxe.io.Bytes chiperText = null;
		//line 13 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
		while (( i < len ))
		{
			//line 15 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
			encryptBlock.__hx_invoke4_o(0.0, vector, ((double) (0) ), haxe.lang.Runtime.undefined, 0.0, vector, ((double) (0) ), haxe.lang.Runtime.undefined);
			//line 16 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
			chiperText = vector.sub(0, vector.length);
			//line 17 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
			int block = ( (( ( i + blockSize ) > len )) ? (( len - i )) : (blockSize) );
			//line 18 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
			{
				//line 18 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
				int _g = 0;
				//line 18 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
				int _g1 = block;
				//line 18 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
				while (( _g < _g1 ))
				{
					//line 18 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
					int j = _g++;
					//line 20 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
					src.b[( i + j )] = ((byte) (( ( src.b[( i + j )] & 255 ) ^ ( vector.b[j] & 255 ) )) );
				}
				
			}
			
			//line 22 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
			vector = chiperText.sub(0, chiperText.length);
			//line 24 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
			i += blockSize;
		}
		
	}
	
	
	public static void decrypt(haxe.io.Bytes src, haxe.io.Bytes iv, int blockSize, haxe.lang.Function decryptBlock)
	{
		//line 30 "C:\\HaxeToolkit\\haxe\\lib\\crypto\\0,3,0\\src\\haxe\\crypto\\mode\\OFB.hx"
		haxe.crypto.mode.OFB.encrypt(src, iv, blockSize, decryptBlock);
	}
	
	
}


