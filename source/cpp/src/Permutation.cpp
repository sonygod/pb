// Generated by Haxe 4.0.0-rc.5+b1fb4afca
#include <hxcpp.h>

#ifndef INCLUDED_Permutation
#include <Permutation.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fdce4ab2ba739b62_5_new,"Permutation","new",0x2fb168d8,"Permutation.new","Permutation.hx",5,0xaa1d7998)
HX_LOCAL_STACK_FRAME(_hx_pos_fdce4ab2ba739b62_61_heapPermutation,"Permutation","heapPermutation",0xc05517b2,"Permutation.heapPermutation","Permutation.hx",61,0xaa1d7998)

void Permutation_obj::__construct(::Array< int > arr, ::Dynamic callBack){
            	HX_STACKFRAME(&_hx_pos_fdce4ab2ba739b62_5_new)
HXLINE(   6)		this->result = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  12)		int i = arr->length;
HXLINE(  13)		int total = 1;
HXLINE(  15)		while((i > 0)){
HXLINE(  16)			total = (total * i);
HXLINE(  17)			i = (i - 1);
            		}
HXLINE(  19)		this->total = total;
HXLINE(  20)		this->callBack = callBack;
HXLINE(  22)		this->heapPermutation(arr,arr->length);
            	}

Dynamic Permutation_obj::__CreateEmpty() { return new Permutation_obj; }

void *Permutation_obj::_hx_vtable = 0;

Dynamic Permutation_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Permutation_obj > _hx_result = new Permutation_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Permutation_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x53fc011e;
}

void Permutation_obj::heapPermutation(::Array< int > a,int size){
            	HX_STACKFRAME(&_hx_pos_fdce4ab2ba739b62_61_heapPermutation)
HXLINE(  62)		if ((size == 1)) {
HXLINE(  64)			::Array< ::Dynamic> _hx_tmp = this->result;
HXDLIN(  64)			_hx_tmp->push(a->slice(0,null()));
HXLINE(  65)			if ((this->result->length == this->total)) {
HXLINE(  66)				this->callBack(this->result);
            			}
            		}
HXLINE(  70)		{
HXLINE(  70)			int _g = 0;
HXDLIN(  70)			int _g1 = size;
HXDLIN(  70)			while((_g < _g1)){
HXLINE(  70)				_g = (_g + 1);
HXDLIN(  70)				int i = (_g - 1);
HXLINE(  71)				this->heapPermutation(a,(size - 1));
HXLINE(  73)				int _hx_int = size;
HXDLIN(  73)				Float a1;
HXDLIN(  73)				if ((_hx_int < 0)) {
HXLINE(  73)					a1 = (((Float)4294967296.0) + _hx_int);
            				}
            				else {
HXLINE(  73)					a1 = (_hx_int + ((Float)0.0));
            				}
HXDLIN(  73)				int int1 = 2;
HXDLIN(  73)				Float a2;
HXDLIN(  73)				if ((int1 < 0)) {
HXLINE(  73)					a2 = (((Float)4294967296.0) + int1);
            				}
            				else {
HXLINE(  73)					a2 = (int1 + ((Float)0.0));
            				}
HXDLIN(  73)				if ((::Std_obj::_hx_int(hx::Mod(a1,a2)) == 1)) {
HXLINE(  74)					int temp = a->__get(0);
HXLINE(  75)					a[0] = a->__get((size - 1));
HXLINE(  76)					a[(size - 1)] = temp;
            				}
            				else {
HXLINE(  78)					int temp1 = a->__get(i);
HXLINE(  79)					a[i] = a->__get((size - 1));
HXLINE(  80)					a[(size - 1)] = temp1;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Permutation_obj,heapPermutation,(void))


hx::ObjectPtr< Permutation_obj > Permutation_obj::__new(::Array< int > arr, ::Dynamic callBack) {
	hx::ObjectPtr< Permutation_obj > __this = new Permutation_obj();
	__this->__construct(arr,callBack);
	return __this;
}

hx::ObjectPtr< Permutation_obj > Permutation_obj::__alloc(hx::Ctx *_hx_ctx,::Array< int > arr, ::Dynamic callBack) {
	Permutation_obj *__this = (Permutation_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Permutation_obj), true, "Permutation"));
	*(void **)__this = Permutation_obj::_hx_vtable;
	__this->__construct(arr,callBack);
	return __this;
}

Permutation_obj::Permutation_obj()
{
}

void Permutation_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Permutation);
	HX_MARK_MEMBER_NAME(result,"result");
	HX_MARK_MEMBER_NAME(total,"total");
	HX_MARK_MEMBER_NAME(callBack,"callBack");
	HX_MARK_END_CLASS();
}

void Permutation_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(result,"result");
	HX_VISIT_MEMBER_NAME(total,"total");
	HX_VISIT_MEMBER_NAME(callBack,"callBack");
}

hx::Val Permutation_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"total") ) { return hx::Val( total ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"result") ) { return hx::Val( result ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"callBack") ) { return hx::Val( callBack ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"heapPermutation") ) { return hx::Val( heapPermutation_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Permutation_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"total") ) { total=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"result") ) { result=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"callBack") ) { callBack=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Permutation_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("result",dd,68,84,08));
	outFields->push(HX_("total",c4,53,32,14));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Permutation_obj_sMemberStorageInfo[] = {
	{hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Permutation_obj,result),HX_("result",dd,68,84,08)},
	{hx::fsInt,(int)offsetof(Permutation_obj,total),HX_("total",c4,53,32,14)},
	{hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Permutation_obj,callBack),HX_("callBack",e5,c5,df,69)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Permutation_obj_sStaticStorageInfo = 0;
#endif

static ::String Permutation_obj_sMemberFields[] = {
	HX_("result",dd,68,84,08),
	HX_("total",c4,53,32,14),
	HX_("callBack",e5,c5,df,69),
	HX_("heapPermutation",3a,ab,b8,7c),
	::String(null()) };

hx::Class Permutation_obj::__mClass;

void Permutation_obj::__register()
{
	Permutation_obj _hx_dummy;
	Permutation_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("Permutation",e6,5c,6e,f6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Permutation_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Permutation_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Permutation_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Permutation_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

